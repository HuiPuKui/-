# 2024/1/4
# 1. JVM 内存结构/内存分区？
java 略

# 2. 岛屿数量
https://leetcode.cn/problems/number-of-islands/
```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> st(n, vector<bool>(m, false));

        int res = 0;
        int dx[5] = {0, 0, 1, -1}, dy[5] = {1, -1, 0, 0};

        function<void(int x, int y)> dfs = [&](int x, int y) {
            st[x][y] = true;
            for (int i = 0; i < 4; ++i)
            {
                int xx = x + dx[i], yy = y + dy[i];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                if (st[xx][yy] == true || grid[xx][yy] == '0') continue;
                dfs(xx, yy);
            }
        };

        for (int i = 0; i < n; ++i)
            for (int j = 0; j < m; ++j)
                if (grid[i][j] == '1' && st[i][j] == false)
                {
                    dfs(i, j);
                    res ++;
                }
        return res;
    }
};
```

# 3. move 了解吗？有什么作用？
高效的资源转换机制，避免不必要的拷贝操作
场景：在容器中移动元素、在算法中交换数据等
注意：只有可移动的对象才可以使用移动语义，否则可能会导致未定义行为

**作用：避免不必要的拷贝，只需要进行一次内存分配和一次指针拷贝，不需要进行多次拷贝操作**
移动构造函数、移动赋值运算符

# 4. 智能指针的原理、常用的智能指针及实现
* shared_ptr
* unique_ptr
* weak_ptr
* auto_ptr

# 5. 数据库并发事务会带来哪些问题？脏读、幻读、丢弃更改、不可重复读的区别？
* 脏读
* 幻读
* 丢弃修改
* 不可重复读

# 6. 多路复用了解吗？讲一下什么是 IO 多路复用
允许单个进程同时监视多个文件描述符，当一个或多个文件描述符准备好读或写时，它就可以立即响应。这种技术可以提高系统的并发性和响应能力，减少系统资源的浪费。
* select
  
最多 1024 个，两遍遍历，两遍循环

* poll

链表，监听文件描述符的个数没有限制

* epoll

红黑树，epoll 是 Linux 所持有，监听文件描述符的个数没有限制，有边缘触发，默认水平触发

# 7. Linux 中异常和中断的区别/键盘敲击发生的中断是怎么回事
* 中断
     
            发送            通知
硬件设备生产 ――――――> 处理器 ――――――――> 操作系统（内核）

* 异常

         通知
处理器 ――――――――> 操作系统（内核）

相同点：

* 最后都是由 CPU 发送给内核，由内核去处理
* 处理程序的流程都是相似的

不同点：
* 异常由 CPU 产生，中断由硬件产生
* 内核需要根据异常还是中断调用不同的处理程序
* 中断不是时钟同步的，异常是时钟同步的
* 中断：处于中断上下文； 异常：处于进程上下文中

# 8. 你知道哪些分布式锁？
### Redis 的 RedLock 锁

### 基于 ZooKeeper 的分布式锁

# 9. 寻找峰值
https://leetcode.cn/problems/find-peak-element/

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        nums.push_back(-2147483648);
        for (int i = 0; i + 1 < nums.size(); ++i)
        {
            if (i == 0 && nums[i] > nums[i + 1]) return i;
            else if (i && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) return i;
        }
        return 0;
    }
};
```

# 10. HTTP 1.0/1.1/2/3
* HTTP 1.0 : 浏览器每次请求都需要建立一个 TCP 连接
* HTTP 1.1 ： 长连接 和 网络管道传输
* HTTP 2.0 ： 二进制传输、并发、头部压缩、服务器主动推送
* HTTP 3.0 ： UDP QUIC
