# 2024/1/4
# 1. JVM 内存结构/内存分区？
java 略

# 2. 岛屿数量
https://leetcode.cn/problems/number-of-islands/
```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> st(n, vector<bool>(m, false));

        int res = 0;
        int dx[5] = {0, 0, 1, -1}, dy[5] = {1, -1, 0, 0};

        function<void(int x, int y)> dfs = [&](int x, int y) {
            st[x][y] = true;
            for (int i = 0; i < 4; ++i)
            {
                int xx = x + dx[i], yy = y + dy[i];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                if (st[xx][yy] == true || grid[xx][yy] == '0') continue;
                dfs(xx, yy);
            }
        };

        for (int i = 0; i < n; ++i)
            for (int j = 0; j < m; ++j)
                if (grid[i][j] == '1' && st[i][j] == false)
                {
                    dfs(i, j);
                    res ++;
                }
        return res;
    }
};
```

# 3. move 了解吗？有什么作用？
高效的资源转换机制，避免不必要的拷贝操作
场景：在容器中移动元素、在算法中交换数据等
注意：只有可移动的对象才可以使用移动语义，否则可能会导致未定义行为

**作用：避免不必要的拷贝，只需要进行一次内存分配和一次指针拷贝，不需要进行多次拷贝操作**
移动构造函数、移动赋值运算符

# 4. 智能指针的原理、常用的智能指针及实现
* shared_ptr
* unique_ptr
* weak_ptr
* auto_ptr

# 5. 数据库并发事务会带来哪些问题？脏读、幻读、丢弃更改、不可重复读的区别？
* 脏读
* 幻读
* 丢弃修改
* 不可重复读

# 6. 多路复用了解吗？讲一下什么是 IO 多路复用
允许单个进程同时监视多个文件描述符，当一个或多个文件描述符准备好读或写时，它就可以立即响应。这种技术可以提高系统的并发性和响应能力，减少系统资源的浪费。
* select
  
最多 1024 个，两遍遍历，两遍循环

* poll

链表，监听文件描述符的个数没有限制

* epoll

红黑树，epoll 是 Linux 所持有，监听文件描述符的个数没有限制，有边缘触发，默认水平触发

# 7. Linux 中异常和中断的区别/键盘敲击发生的中断是怎么回事
* 中断    
             发送            通知
硬件设备生产 ――――――> 处理器 ――――――――> 操作系统（内核）
* 异常  
         通知
处理器 ――――――――> 操作系统（内核）

相同点：

* 最后都是由 CPU 发送给内核，由内核去处理
* 处理程序的流程都是相似的

不同点：
* 异常由 CPU 产生，中断由硬件产生
* 内核需要根据异常还是中断调用不同的处理程序
* 中断不是时钟同步的，异常是时钟同步的
* 中断：处于中断上下文； 异常：处于进程上下文中

# 8. 你知道哪些分布式锁？
### Redis 的 RedLock 锁

### 基于 ZooKeeper 的分布式锁

# 9. 寻找峰值
https://leetcode.cn/problems/find-peak-element/

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        nums.push_back(-2147483648);
        for (int i = 0; i + 1 < nums.size(); ++i)
        {
            if (i == 0 && nums[i] > nums[i + 1]) return i;
            else if (i && nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) return i;
        }
        return 0;
    }
};
```

# 10. HTTP 1.0/1.1/2/3
* HTTP 1.0 : 浏览器每次请求都需要建立一个 TCP 连接
* HTTP 1.1 ： 长连接 和 网络管道传输
* HTTP 2.0 ： 二进制传输、并发、头部压缩、服务器主动推送
* HTTP 3.0 ： UDP QUIC

# 2024/1/6
# 11. 数据库引擎 InnoDB 与 MyISAM 的区别
### InnoDB
* 是 MySQL 默认的事务型存储引擎，
* 实现了四个标准的隔离级别，默认级别是可重复读。通过 MVCC + 间隙锁 防止幻读
* 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升
* 内部做了很多优化
* 支持真正的在线热备份

### MyISAM
* 设计简单，数据以紧密格式存储
* 提供了大量的特性，包括压缩表、空间数据索引等。
* 不支持事务
* 不支持行级锁，只能对整张表加锁。

# 12. Golang 数组怎么动态扩容
略

# 13. 封包和拆包你听说过吗？它是基于 TCP 还是 UDP 的
封包和拆包都是基于 TCP 的概念。因为TCP 是无边界的流传输，所以需要对 TCP 进行封包和拆包，确保发送和接受的数据不粘连
* 封包：封包就是在发送数据包的时候为每个 TCP 数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。
* 拆包：接收方在接收到报文后提取包头中的长度信息进行截取

# 14. 堆和栈的区别
* 管理方式：
* 内存管理机制：
* 空间大小：
* 碎片问题：
* 生长方向
* 分配方式
* 分配效率

# 15. 如何保证缓存与数据库双写时的数据一致性
首先，只要用缓存，就可能涉及到缓存与数据库双存储双写，只要双写，就一定会有数据一致性的问题
### 如何解决一致性问题
一般来说如果系统不是严格要求缓存 + 数据库必须一致性的话，最好不要做这个方案，最好将读请求和写请求串行化，但是会导致系统的吞吐量大幅度降低

### 预留缓存模式
最经典的缓存 + 数据库读写的模式，就是 **预留缓存模式**
* 读的时候先读缓存，缓存没有的话，再读数据库，然后取出数据后放入缓存，同时返回响应。
* 更新的时候，先删除缓存，然后再更新数据库，这样读的时候就会发现缓存中没有数据而直接去数据库中拿数据了。

在高并发的业务场景下，数据库的性能瓶颈往往都是用户并发量访问过大。所以，一般都使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接去访问 MySQL 等数据库，从而减少网络请求的延迟响应。

# 16. BIO/NIO/AIO 的区别
* BIO 同步阻塞IO：用户发起一个 IO 操作后，必须等待 IO 操作的真正完成后，才能继续运行
* NIO 同步非阻塞IO：客户端与服务器通过 Channel 连接，采用多路复用器轮询注册的 Channel。提高吞吐量和可靠性。用户发起一个 IO 操作以后，可做其他事情，但用户进程需要轮询 IO 操作是否完成，这样造成不必要的 CPU 资源浪费
* AIO 异步非阻塞IO：采用异步通道实现异步通信，其 read 和 write 方法均是异步方法。用户进程发起一个 IO 操作，然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知。

# 17. JVM内存结构/内存分区
java 略

# 18. TCP 和 UDP 的区别
连、服、可、拥、首、传、分

# 19. 说一说你理解的内存对齐以及原因
1. 分配内存的顺序是按照声明的顺序
2. 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍就空出内存，直到偏移量是整数倍为止
3. 最后整个结构体的大小必须是里面变量类型最大值的整数倍

# 20. C++ 的多态是如何实现的
静态多态：重载等

动态多态：虚函数

### 虚表和虚基表指针
虚表：虚函数表的缩写，类中含有 virtual 关键字修饰的方法时，编译器会自动生成虚表，他是在编译器确定的

虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针，它是在构造函数中被初始化的。

