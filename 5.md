# 2024/1/10
# 1. 智能指针的原理、常用的智能指针及实现
* shared_ptr
* unique_ptr
* weak_ptr
* auto_ptr

# 2. 毒药毒白鼠，找出哪个瓶子中是毒药
二进制解决

# 3. 你可以讲一下三握四挥的具体过程吗？包括三次握手和四次挥手？
### 三次握手
第一次：客 ---SYN---> 服   客户端 CLOSE -> SYN_SEND     
第二次：客 <--ACK---- 服   客户端 SYN_SEND -> ESTABLISHED 服务端 CLOSE -> SYN_RECV     
第三次：客 ---ACK---> 服                                 服务端 SYN_RECV -> ESTABLISHED

三次可以让客户端、服务端确认自己的收发功能正常

### 四次挥手
第一次挥手：

client 发送 FIN             ESTABLISHED -> FIN_WAIT1

第二次挥手：

server 收到 FIN 发送 ACK     ESTABLISHED -> CLOSE_WAIT

client 收到 ACK             FIN_WAIT1 -> FIN_WAIT2

第三次挥手：

server 发送 FIN             CLOSE_WAIT -> LAST_ACK

第四次挥手：

client 收到 FIN 发送 ACK     FIN_WAIT2 -> TIME_WAIT

server 收到 ACK             CLOSE_WAIT -> CLOSED

经过 2MSL client            TIME_WAIT -> CLOSED

# 4. 实现 atoi 函数（字符串转换整数）
https://leetcode.cn/problems/string-to-integer-atoi/
```cpp
class Solution {
public:
    int myAtoi(string s) {
        stringstream in(s);
        int x;
        in >> x;
        return x;
    }
};
```

# 5. 在 24 小时里面时针分针秒针可以重合多少次
两次，0 点和 12点

# 6. 四次握手中的 ACK 链接和之后的释放链可以合并吗？/四次握手中确认报文和释放连接可以同时发送吗？
可以        
首先明确下 ACK 报文和 FIN 报文的作用是不同的，ACK 报文用于确认客户端发送的 FIN 报文已经被正确接收，而 FIN 报文则用于通知客户端服务端已经准备好释放连接      
在这两个报文中，ACK 报文是必须的，因为客户端需要收到服务端的确认才能确定服务端已经收到了自己发送的 FIN 报文     
当开启延迟确认机制时可以进行合并，如果没有开启，自然不可以

# 7. 100 个努力猜帽子颜色
最后面的一个人 50%，其他人 100%

# 8. 除了常见的拥塞控制、滑动窗口等机制外，TCP 还有什么机制可以保证可以？比如报文上的一些检验等？
还有其他层上的方式可以保证数据的可靠传输        
比如在数据链路层和物理层上，常用的技术包括循环冗余校验（CRC），帧检验序列（FCS）等，用于检测和纠正数据传输中的错误      
在应用层上，常用的方法包括数据重传、数据校验等。

# 9. 小猴子搬香蕉
第一阶段：一米  <- -> <-  一米三根，一直到17米，这时候剩 49 根
第二阶段：直接抱着走，49 - 33 = 16

# 10. 数组中的第 k 个最大元素
https://leetcode.cn/problems/kth-largest-element-in-an-array
```cpp
class Solution {
public:

    int quick_find(vector<int> &nums, int l, int r, int k)
    {
        if (l >= r) return nums[k - 1];
        int i = l - 1, j = r + 1, x = nums[l + r >> 1];
        while (i < j)
        {
            while (nums[++ i] > x) ;
            while (nums[-- j] < x) ;
            if (i < j) swap(nums[i], nums[j]);
        }
        quick_find(nums, l, j, k);
        quick_find(nums, j + 1, r, k);
        return nums[k - 1];
    }

    int findKthLargest(vector<int>& nums, int k) {
        return quick_find(nums, 0, nums.size() - 1, k);
    }
};
```