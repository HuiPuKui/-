# 2024/1/2
# 1. 如何排查一条慢 SQL？可以从哪些方面入手？
如果是一个 sql，可以通过 explain 的指令去查这个 sql 的执行计划

如果有数据库终端的话，也可以通过开启 mysql 的慢日志查询，设置好事件阈值，进行捕获

# 2. 说一说你了解的关于 lambda 函数的全部知识
利用 lambda 表达式可以编写内嵌的匿名函数，用以替代独立函数或者函数对象

每当你定义一个 lambda 表达式后，编译器会自动生成一个匿名类，我们称为闭包类型。那么在运行时，这个 lambda 表达式就会返回一个匿名的闭包实例，其实一个右值

语法：\[捕获列表\](参数) mutable -&gt; 返回值 { 函数体 }

lambda 必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体


# 3. 在浏览器地址栏输入一个 URL 后回车，背后会进行哪些技术步骤
* 域名解析
* 发起 TCP 的三次握手
* 建立 TCP 连接后发送 HTTP 请求
* 服务器响应 HTTP 请求，浏览器得到 html 代码
* 浏览器解析 html 代码，并请求 html 代码中的资源
* 浏览器对页面进行渲染呈现给用户

# 4. 如何设计一个高性能、高并发、高可用、高可靠、可扩展的系统
无锁化、零拷贝、序列化、池子化、并发化、异步化、缓存、分片、存储

# 5. 事务的四大特性 ACID
原子性：事务所包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响(undolog)

一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。(原子性、隔离性、持久性)

隔离性：数据库允许多个并发事务同时对其数据进行读写和修改。隔离性可以防止的一个事务并发执行时由于交叉执行而导致数据的不一致（MVCC 和 锁机制）
        事务的隔离级别：读未提交、读提交、可重复读、串行化

持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失（redolog）

# 6. 接雨水
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0, n = height.size();
        vector<int> LMax(n, 0); vector<int> RMax(n, 0);

        for (int i = 0; i < n; i ++) LMax[i] = i == 0 ? height[i] : max(LMax[i - 1], height[i]);
        for (int i = n - 1; i >= 0; i --) RMax[i] = i == n - 1 ? height[i] : max(RMax[i + 1], height[i]);
        for (int i = 1; i < n - 1; i ++) res += max(min(LMax[i - 1], RMax[i + 1]), height[i]) - height[i];

        return res;
    }
};
```

# 7. TCP 是如何保证可靠传输的
* 确认和重传
* 数据检验
* 数据合理分片和排序
* 流量控制
* 拥塞控制

# 8. 线程与进程的比较或者说区别
* 调度：线程是调度的基本单位，进程是拥有资源的基本单位
* 并发性：一个进程内多个线程可以并发，多个进程可以并发
* 拥有资源：线程不拥有系统资源，一个进程的多个线程可以共享隶属进程的资源。进程是拥有资源的独立单位
* 系统开销：线程开销小

# 9. 数据库的事务隔离级别有哪些
* 未提交读
* 提交读
* 重复读
* 串行化

# 10. C++11 有哪些新特性
* nullptr 替代 NULL
* 引入了 auto 和 decltype 实现类型推导
* 基于范围的 for 循环 `for (auto &i : res) { }`
* 类和结构体中的初始化列表
* Lambda 表达式
* std::forward_list 单项链表
* 右值引用和 move 语义
* 无序容器和正则表达式
* 成员变量默认初始化
* 智能指针等
  
# 2024/1/3
# 11. Linux 和 Windows 下的进程通信方法和线程通信方法分别有哪些

### 进程通信方法
* 管道：允许一个进程和另一个与它有共同祖先的进程之间进行通信
* 命名管道：类似于管道，但是它可以用于任何两个进程之间的通信
* 消息队列：消息队列是消息的连接表
* 信号量：信号量主要作为进程间以及同进程不同线程之间的同步手段
* 共享内存：它使多个进程可以访问同一块内存空间
* 信号：信号是比较复杂的通信方式，用于通知接受进程有某种事情发生
* 内存映射：每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它
* Socket：用于不同机器之间的进程间通信

### 线程通信方式
#### Linux
* 信号：类似进程间的信号处理
* 锁机制：互斥锁、读写锁、自旋锁
* 条件变量：使用通知的方式解锁，与互斥锁配合使用
* 信号量：包括无名线程信号量和命名线程信号量

#### Windows
* 全局变量：
* Message 消息机制
* CEvent 对象

# 12. TCP 和 UDP 的区别
连、服、可、拥、首、传、分

# 13. 具体说一下计算机网络三握四挥中的四挥？
第一次挥手：

client 发送 FIN             ESTABLISHED -> FIN_WAIT1

第二次挥手：

server 收到 FIN 发送 ACK     ESTABLISHED -> CLOSE_WAIT

client 收到 ACK             FIN_WAIT1 -> FIN_WAIT2

第三次挥手：

server 发送 FIN             CLOSE_WAIT -> LAST_ACK

第四次挥手：

client 收到 FIN 发送 ACK     FIN_WAIT2 -> TIME_WAIT

server 收到 ACK             CLOSE_WAIT -> CLOSED

经过 2MSL client            TIME_WAIT -> CLOSED


# 14. Redis 怎么实现分布式锁
SET NX  实现 Key 不存在才插入

这个指令是 Redis 的原子命令，可以把一个 Key 设置其对应的 Value

Key 不存在、插入成功、加锁成功

Key 存在、插入失败、加锁失败

成功获取锁并且执行完临界区操作之后，可以用 del 命令在 redis 删除这个 Key

# 15. 在并发编程时，在需要加锁时，不加锁会有什么问题
两个线程使用同一个全局变量会有不一致的问题，比如 a 线程把全局变量加 1，b线程读的时候，如果还是从缓存中读的，那么会没有发现这个更新，就会产生不一致的问题。

# 16. Go 携程的通讯有哪些方式
* 共享内存
* 消息队列
* 信号量

# 17. 死锁
### 死锁产生的原因
* 互斥、不可剥夺、请求和保留、循环等待

### 死锁的解决方案
* 保证上锁的顺序一致

### 死锁的必要条件
* 互斥、不可剥夺、请求和保留、循环等待

### 处理方法
* 鸵鸟策略
* 死锁检测与死锁恢复
* 死锁预防
* 死锁避免

### 死锁恢复
* 利用抢占恢复
* 利用回滚恢复
* 通过杀死进程恢复

### 死锁预防
* 破环四个条件中的一个

### 死锁避免
* 银行家算法

# 18. HTTPS 和 HTTP 的区别
1. HTTP 明文传输 HTTPS 是 SSL + HTTP 加密传输、身份认证
2. HTTPS 需要 CA 证书
3. 不同的连接方式，端口也不同 HTTP 80    HTTPS 443

# 19. 讲一下程序的内存分区/内存模型
堆、栈、静态存储区、常量区、自由存储区、代码区

# 20. Redis 的五种底层数据结构
### SDS 简单动态字符串

优点：
* 获取字符串长度的复杂度为O(1)
* 杜绝缓冲区溢出
* 减少修改字符串长度时所需要的内存重分配次数
* 二进制安全
* 兼容部分 C 字符串的函数

### 链表
特性：
* 被广泛用于实现 Redis 的各种功能，比如列表建、发布与订阅、慢查询、监视器等
* 双向链表
* 是 list 结构表示，带有表头节点指针、表尾节点指针、链表长度等数据
* 前置节点和后置节点都指向 NULL，所以是无环链表
* 通过为链表设置不同的类型特定函数，Redis 的链表可以用于保存不同类型的数据

### 字典
特性：
* 用于包含数据库和哈希值
* 每个字典有两个哈希表，一个平时用，一个 rehash 用
* Redis 采用 MurmurHash2 算法来计算键的哈希值
* 哈希表使用链地址法来解决键冲突

### 跳跃表
特性：
* 有序集合
* Redis 的调表实现由 zskiplist 和 zskiplistNode 组成
* 每个跳跃表节点的层高都是 1 至 32 之间的随机数
* 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的
* 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序
* 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高。

### 压缩列表
特性：
* 为了节省内存造的列表结构
